<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Leetcode刷题s on 还没想好叫什么</title><link>https://blog.qianjy.net/leetcode%E5%88%B7%E9%A2%98/</link><description>Recent content in Leetcode刷题s on 还没想好叫什么</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 17 Dec 2022 00:37:52 +0800</lastBuildDate><atom:link href="https://blog.qianjy.net/leetcode%E5%88%B7%E9%A2%98/index.xml" rel="self" type="application/rss+xml"/><item><title>两数之和</title><link>https://blog.qianjy.net/leetcode%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link><pubDate>Sat, 17 Dec 2022 00:37:52 +0800</pubDate><guid>https://blog.qianjy.net/leetcode%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid><description>两数之和 涉及相关知识：array, hash-table
leetcode原题要求：
给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值target的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？
方法1：枚举
class Solution { public int[] twoSum(int[] nums, int target) { int n=nums.length; for(int i = 0; i &amp;lt; n - 1; i++){ for(int j = i + 1; j &amp;lt; n; j++){ if(nums[i] + nums[j] == target){ return new int[] {i, j}; } } } return new int[] {0}; } } 上述算法运用了数组的基本知识，时间复杂度为$O(N^2)$，接下来考虑一种时间复杂度更小的方法。
方法2：哈希表</description></item></channel></rss>